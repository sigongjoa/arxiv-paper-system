import logging
from typing import Dict, Optional
from datetime import datetime
import json

logger = logging.getLogger(__name__)

class EnhancedNotionSaver:
    def __init__(self, notion_manager=None):
        from ..automation.notion_saver import NotionSaver
        self.notion_saver = notion_manager or NotionSaver()
        
    async def save_enhanced_analysis(self, arxiv_id: str, analysis_data: Dict, analysis_type: str = "comprehensive") -> Dict:
        """Save enhanced AI analysis to Notion with structured format"""
        try:
            logger.info(f"Saving enhanced {analysis_type} analysis to Notion for {arxiv_id}")
            
            # Create structured page title
            timestamp = datetime.now().strftime("%Y%m%d_%H%M")
            page_title = f"Enhanced Analysis: {arxiv_id} - {analysis_type.title()} ({timestamp})"
            
            # Build page content based on analysis type
            if analysis_type == "comprehensive":
                content = self._build_comprehensive_content(analysis_data)
            elif analysis_type == "methodology":
                content = self._build_methodology_content(analysis_data)
            elif analysis_type == "reproducibility":
                content = self._build_reproducibility_content(analysis_data)
            elif analysis_type == "research_gaps":
                content = self._build_research_gaps_content(analysis_data)
            else:
                content = self._build_generic_content(analysis_data)
            
            # Save to Notion
            result = self.notion_saver.save_to_notion(page_title, content)
            
            if result.get("success"):
                logger.info(f"Enhanced analysis saved to Notion: {result.get('page_url')}")
                return {
                    "success": True,
                    "page_url": result.get("page_url"),
                    "page_id": result.get("page_id"),
                    "analysis_type": analysis_type,
                    "arxiv_id": arxiv_id,
                    "saved_at": datetime.now().isoformat()
                }
            else:
                logger.error(f"Failed to save to Notion: {result.get('error')}")
                return {"success": False, "error": result.get("error")}
                
        except Exception as e:
            logger.error(f"Enhanced Notion save failed for {arxiv_id}: {e}")
            return {"success": False, "error": str(e)}
    
    def _build_comprehensive_content(self, data: Dict) -> str:
        """Build content for comprehensive analysis"""
        content = []
        
        # Header with metadata
        content.append("# ğŸ“Š ì¢…í•© ë…¼ë¬¸ ë¶„ì„ ë³´ê³ ì„œ\n")
        content.append(f"**ë¶„ì„ ì¼ì‹œ:** {data.get('analysis_timestamp', 'N/A')}\n")
        content.append(f"**ë¶„ì„ ëª¨ë¸:** {data.get('model_used', 'N/A')}\n")
        content.append(f"**ArXiv ID:** {data.get('arxiv_id', 'N/A')}\n\n")
        
        # Executive Summary
        if 'comprehensive_analysis' in data and 'background' in data['comprehensive_analysis']:
            bg = data['comprehensive_analysis']['background']
            content.append("## ğŸ¯ ì—°êµ¬ ë°°ê²½ ë° ë¬¸ì œ ì •ì˜\n")
            content.append(f"**ë¬¸ì œ ì •ì˜:** {bg.get('problem_definition', 'N/A')}\n\n")
            content.append(f"**ì—°êµ¬ ë™ê¸°:** {bg.get('motivation', 'N/A')}\n\n")
        
        # Methodology Analysis
        if 'methodology_details' in data:
            method = data['methodology_details']
            content.append("## ğŸ”¬ ë°©ë²•ë¡  ë¶„ì„\n")
            content.append(f"**ë°©ë²•ë¡  ìœ í˜•:** {method.get('methodology_type', 'N/A')}\n\n")
            
            if 'core_algorithms' in method:
                content.append("**í•µì‹¬ ì•Œê³ ë¦¬ì¦˜:**\n")
                for algo in method['core_algorithms']:
                    content.append(f"- {algo}\n")
                content.append("\n")
        
        # Quality Assessment
        if 'comprehensive_analysis' in data and 'quality_scores' in data['comprehensive_analysis']:
            scores = data['comprehensive_analysis']['quality_scores']
            content.append("## â­ í’ˆì§ˆ í‰ê°€\n")
            content.append("| í‰ê°€ í•­ëª© | ì ìˆ˜ |\n")
            content.append("|----------|------|\n")
            for key, value in scores.items():
                if isinstance(value, (int, float)):
                    content.append(f"| {key} | {value}/100 |\n")
            content.append("\n")
        
        # Reproducibility Assessment
        if 'reproducibility_assessment' in data:
            repro = data['reproducibility_assessment']
            content.append("## ğŸ”„ ì¬í˜„ê°€ëŠ¥ì„± í‰ê°€\n")
            
            if 'reproducibility_score' in repro:
                content.append("**ì¬í˜„ì„± ì ìˆ˜:**\n")
                for key, value in repro['reproducibility_score'].items():
                    if isinstance(value, (int, float)):
                        content.append(f"- {key}: {value}\n")
                content.append("\n")
            
            if 'missing_elements' in repro:
                content.append("**ê°œì„  í•„ìš” ì‚¬í•­:**\n")
                for element in repro['missing_elements']:
                    content.append(f"- {element}\n")
                content.append("\n")
        
        # Future Directions
        if 'comprehensive_analysis' in data and 'future_directions' in data['comprehensive_analysis']:
            content.append("## ğŸš€ í–¥í›„ ì—°êµ¬ ë°©í–¥\n")
            for direction in data['comprehensive_analysis']['future_directions']:
                content.append(f"- {direction}\n")
            content.append("\n")
        
        # Technical Details (JSON format for reference)
        content.append("## ğŸ“‹ ìƒì„¸ ë¶„ì„ ë°ì´í„°\n")
        content.append("```json\n")
        content.append(json.dumps(data, indent=2, ensure_ascii=False))
        content.append("\n```\n")
        
        return "".join(content)
    
    def _build_methodology_content(self, data: Dict) -> str:
        """Build content for methodology analysis"""
        content = []
        
        content.append("# ğŸ”¬ ë°©ë²•ë¡  ìƒì„¸ ë¶„ì„\n\n")
        content.append(f"**ë¶„ì„ ì¼ì‹œ:** {data.get('extracted_at', 'N/A')}\n\n")
        
        if 'methodology_type' in data:
            content.append(f"**ë°©ë²•ë¡  ìœ í˜•:** {data['methodology_type']}\n\n")
        
        if 'core_algorithms' in data:
            content.append("## í•µì‹¬ ì•Œê³ ë¦¬ì¦˜\n")
            for algo in data['core_algorithms']:
                content.append(f"- {algo}\n")
            content.append("\n")
        
        if 'computational_complexity' in data:
            comp = data['computational_complexity']
            content.append("## ê³„ì‚° ë³µì¡ë„\n")
            content.append(f"- **ì‹œê°„ ë³µì¡ë„:** {comp.get('time_complexity', 'N/A')}\n")
            content.append(f"- **ê³µê°„ ë³µì¡ë„:** {comp.get('space_complexity', 'N/A')}\n")
            content.append(f"- **í•˜ë“œì›¨ì–´ ìš”êµ¬ì‚¬í•­:** {comp.get('hardware_requirements', 'N/A')}\n\n")
        
        # Add full data
        content.append("## ìƒì„¸ ë°ì´í„°\n")
        content.append("```json\n")
        content.append(json.dumps(data, indent=2, ensure_ascii=False))
        content.append("\n```\n")
        
        return "".join(content)
    
    def _build_reproducibility_content(self, data: Dict) -> str:
        """Build content for reproducibility assessment"""
        content = []
        
        content.append("# ğŸ”„ ì¬í˜„ê°€ëŠ¥ì„± í‰ê°€ ë³´ê³ ì„œ\n\n")
        content.append(f"**í‰ê°€ ì¼ì‹œ:** {data.get('assessed_at', 'N/A')}\n\n")
        
        if 'reproducibility_score' in data:
            content.append("## ì¬í˜„ì„± ì ìˆ˜\n")
            content.append("| í‰ê°€ í•­ëª© | ì ìˆ˜ |\n")
            content.append("|----------|------|\n")
            for key, value in data['reproducibility_score'].items():
                if isinstance(value, (int, float)):
                    content.append(f"| {key} | {value} |\n")
            content.append("\n")
        
        if 'reproducibility_checklist' in data:
            content.append("## ì¬í˜„ì„± ì²´í¬ë¦¬ìŠ¤íŠ¸\n")
            for key, value in data['reproducibility_checklist'].items():
                status = "âœ…" if value else "âŒ"
                content.append(f"- {status} {key}: {value}\n")
            content.append("\n")
        
        if 'recommendations_for_improvement' in data:
            content.append("## ê°œì„  ê¶Œì¥ì‚¬í•­\n")
            for rec in data['recommendations_for_improvement']:
                content.append(f"- {rec}\n")
            content.append("\n")
        
        content.append("## ìƒì„¸ ë°ì´í„°\n")
        content.append("```json\n")
        content.append(json.dumps(data, indent=2, ensure_ascii=False))
        content.append("\n```\n")
        
        return "".join(content)
    
    def _build_research_gaps_content(self, data: Dict) -> str:
        """Build content for research gaps analysis"""
        content = []
        
        content.append("# ğŸ” ì—°êµ¬ ê³µë°± ë° ê¸°íšŒ ë¶„ì„\n\n")
        content.append(f"**ë¶„ì„ ì¼ì‹œ:** {data.get('identified_at', 'N/A')}\n\n")
        
        if 'identified_gaps' in data:
            gaps = data['identified_gaps']
            content.append("## ì‹ë³„ëœ ì—°êµ¬ ê³µë°±\n")
            
            for gap_type, gap_list in gaps.items():
                content.append(f"### {gap_type}\n")
                for gap in gap_list:
                    content.append(f"- {gap}\n")
                content.append("\n")
        
        if 'research_opportunities' in data:
            opportunities = data['research_opportunities']
            content.append("## ì—°êµ¬ ê¸°íšŒ\n")
            
            for opp_type, opp_list in opportunities.items():
                content.append(f"### {opp_type}\n")
                for opp in opp_list:
                    content.append(f"- {opp}\n")
                content.append("\n")
        
        if 'recommended_next_steps' in data:
            content.append("## ê¶Œì¥ ë‹¤ìŒ ë‹¨ê³„\n")
            for step in data['recommended_next_steps']:
                content.append(f"- {step}\n")
            content.append("\n")
        
        content.append("## ìƒì„¸ ë°ì´í„°\n")
        content.append("```json\n")
        content.append(json.dumps(data, indent=2, ensure_ascii=False))
        content.append("\n```\n")
        
        return "".join(content)
    
    def _build_generic_content(self, data: Dict) -> str:
        """Build generic content for any analysis type"""
        content = []
        
        content.append("# ğŸ“‹ AI ë¶„ì„ ê²°ê³¼\n\n")
        content.append(f"**ë¶„ì„ ì¼ì‹œ:** {datetime.now().isoformat()}\n\n")
        
        content.append("## ë¶„ì„ ê²°ê³¼\n")
        content.append("```json\n")
        content.append(json.dumps(data, indent=2, ensure_ascii=False))
        content.append("\n```\n")
        
        return "".join(content)
    
    async def save_citation_analysis(self, arxiv_id: str, citation_data: Dict) -> Dict:
        """Save citation analysis to Notion"""
        try:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M")
            page_title = f"Citation Analysis: {arxiv_id} ({timestamp})"
            
            content = []
            content.append("# ğŸ”— ì¸ìš© ê´€ê³„ ë¶„ì„ ë³´ê³ ì„œ\n\n")
            content.append(f"**ë¶„ì„ ì¼ì‹œ:** {citation_data.get('analysis_timestamp', 'N/A')}\n")
            content.append(f"**ë…¼ë¬¸ ID:** {arxiv_id}\n")
            content.append(f"**ì´ ì¸ìš© ìˆ˜:** {citation_data.get('total_citations', 0)}\n\n")
            
            if 'pattern_summary' in citation_data:
                summary = citation_data['pattern_summary']
                content.append("## ğŸ“Š ì¸ìš© íŒ¨í„´ ìš”ì•½\n")
                
                if 'citation_patterns' in summary:
                    patterns = summary['citation_patterns']
                    content.append(f"**ì£¼ìš” ì¸ìš© ëª©ì :** {patterns.get('primary_citation_purpose', 'N/A')}\n")
                    content.append(f"**ì§€ë°°ì  ê´€ê³„ ìœ í˜•:** {patterns.get('dominant_relationship_type', 'N/A')}\n\n")
                
                if 'citation_quality' in summary:
                    quality = summary['citation_quality']
                    content.append(f"**í‰ê·  ê´€ë ¨ì„±:** {quality.get('average_relevance', 'N/A')}\n")
                    content.append(f"**ì¸ìš© ê¹Šì´:** {quality.get('citation_depth', 'N/A')}\n\n")
            
            if 'classifications' in citation_data:
                content.append("## ğŸ“‹ ì¸ìš© ë¶„ë¥˜ ê²°ê³¼\n")
                content.append("| ì¸ìš© ë…¼ë¬¸ | ê´€ê³„ ìœ í˜• | ê´€ë ¨ì„± ì ìˆ˜ | ì˜í–¥ë ¥ |\n")
                content.append("|----------|----------|------------|--------|\n")
                
                for classification in citation_data['classifications'][:10]:  # Top 10
                    paper_id = classification.get('cited_paper_id', 'N/A')
                    rel_type = classification.get('relationship_type', 'N/A')
                    relevance = classification.get('relevance_score', 'N/A')
                    influence = classification.get('influence_level', {}).get('overall_influence', 'N/A')
                    content.append(f"| {paper_id} | {rel_type} | {relevance} | {influence} |\n")
                content.append("\n")
            
            content.append("## ğŸ“„ ìƒì„¸ ë¶„ì„ ë°ì´í„°\n")
            content.append("```json\n")
            content.append(json.dumps(citation_data, indent=2, ensure_ascii=False))
            content.append("\n```\n")
            
            result = self.notion_saver.save_to_notion(page_title, "".join(content))
            
            if result.get("success"):
                return {
                    "success": True,
                    "page_url": result.get("page_url"),
                    "page_id": result.get("page_id"),
                    "arxiv_id": arxiv_id,
                    "saved_at": datetime.now().isoformat()
                }
            else:
                return {"success": False, "error": result.get("error")}
                
        except Exception as e:
            logger.error(f"Citation analysis Notion save failed for {arxiv_id}: {e}")
            return {"success": False, "error": str(e)}
